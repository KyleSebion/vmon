<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Console</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        :root {
            box-sizing: border-box;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                sans-serif;
        }

        *,
        *::before,
        *::after {
            box-sizing: inherit;
        }

        body {
            margin: 0;
            min-height: 100dvh;
            display: flex;
            justify-content: center;
            align-items: stretch;
            background: #111827;
            color: #111827;
            font-size: 14px;
        }

        .app {
            max-width: 960px;
            width: 100%;
            margin: 1.25rem;
            padding: 1.25rem;
            border-radius: 0.75rem;
            background: #ffffff;
            color: #111827;
            box-shadow: 0 18px 45px rgba(15, 23, 42, 0.3);
            display: flex;
            flex-direction: column;
            gap: 0.9rem;
        }

        .header {
            display: flex;
            flex-direction: column;
            gap: 0.55rem;
        }

        .header-top {
            display: flex;
            flex-wrap: wrap;
            justify-content: right;
            align-items: baseline;
            gap: 0.4rem;
        }

        .title {
            font-size: 1.05rem;
            font-weight: 600;
            color: #111827;
        }

        .uptime-stack {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.15rem;
        }

        .uptime-inline {
            font-size: 0.65rem;
            font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono",
                "Courier New", monospace;
            white-space: nowrap;
            color: #111827;
        }

        .uptime-inline strong {
            font-weight: 1200;
        }

        .link-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
            margin-top: 0.3rem;
        }

        .link-bar a {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.35rem 0.75rem;
            border-radius: 999px;
            border: 1px solid #d4d4d8;
            background: #f9fafb;
            font-size: 0.85rem;
            text-decoration: none;
            color: #111827;
            cursor: pointer;
            transition: background 120ms ease, transform 80ms ease,
                box-shadow 120ms ease;
            box-shadow: 0 1px 2px rgba(15, 23, 42, 0.1);
        }

        .link-bar a span.path {
            font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono",
                "Courier New", monospace;
            font-size: 0.75rem;
            color: #4b5563;
        }

        .link-bar a:hover {
            background: #e5e7eb;
            transform: translateY(-1px);
        }

        .link-bar a:active {
            transform: translateY(0);
            box-shadow: none;
        }

        .link-bar a.active {
            background: #2563eb;
            color: #ffffff;
            border-color: #2563eb;
            box-shadow: 0 3px 8px rgba(37, 99, 235, 0.45);
        }

        .settings-card {
            margin-top: 0.4rem;
            padding: 0.6rem 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
            background: #f9fafb;
            font-size: 0.8rem;
            display: flex;
            flex-direction: column;
            gap: 0.45rem;
        }

        .settings-title {
            font-weight: 600;
            margin-bottom: 0.15rem;
            color: #111827;
        }

        .settings-row {
            display: flex;
            flex-wrap: wrap;
            gap: 0.6rem;
            align-items: center;
        }

        .settings-field {
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
            min-width: 150px;
            flex: 1 1 180px;
        }

        .settings-label {
            font-size: 0.8rem;
            color: #111827;
        }

        .settings-input {
            border-radius: 0.35rem;
            border: 1px solid #d4d4d8;
            padding: 0.25rem 0.45rem;
            font-size: 0.8rem;
            font-family: inherit;
            color: #111827;
            background: #ffffff;
        }

        .settings-input:focus {
            outline: 2px solid #2563eb;
            outline-offset: 1px;
        }

        .settings-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.3rem 0.75rem;
            border-radius: 999px;
            border: 1px solid #2563eb;
            background: #2563eb;
            color: #ffffff;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            margin-top: 0.9rem;
            transition: background 120ms ease, transform 80ms ease,
                box-shadow 120ms ease;
            white-space: nowrap;
        }

        .settings-btn:hover {
            background: #1d4ed8;
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(37, 99, 235, 0.4);
        }

        .settings-btn:active {
            transform: translateY(0);
            box-shadow: none;
        }

        .main {
            display: flex;
            flex-direction: column;
            gap: 0.45rem;
            min-height: 0;
            flex: 1 1 auto;
            margin-top: 0.3rem;
        }

        .output-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.65rem;
            font-size: 0.85rem;
            color: #111827;
        }

        .output-label {
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .output-label-code {
            padding: 0.15rem 0.45rem;
            border-radius: 999px;
            background: #e5e7eb;
            font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono",
                "Courier New", monospace;
            font-size: 0.75rem;
            color: #111827;
        }

        .status {
            font-size: 0.8rem;
            color: #4b5563;
        }

        .copy-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.3rem 0.75rem;
            border-radius: 999px;
            border: 1px solid #d4d4d8;
            font-size: 0.8rem;
            background: #f9fafb;
            color: #111827;
            cursor: pointer;
            transition: background 120ms ease, transform 80ms ease,
                box-shadow 120ms ease;
        }

        .copy-btn:hover {
            background: #e5e7eb;
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(15, 23, 42, 0.18);
        }

        .copy-btn:active {
            transform: translateY(0);
            box-shadow: none;
        }

        .copy-btn[data-copied="true"] {
            color: #16a34a;
        }

        .output {
            flex: 1 1 auto;
            height: 40dvh;
            width: 100%;
            resize: vertical;
            padding: 0.5rem 0.6rem;
            border-radius: 0.5rem;
            border: 1px solid #d4d4d8;
            background: #020617;
            color: #f9fafb;
            font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono",
                "Courier New", monospace;
            font-size: 0.6rem;
            overflow: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            margin-bottom: 0;
        }
    </style>
</head>

<body>
    <div class="app">
        <header class="header">
            <div class="header-top">
                <div class="uptime-stack">
                    <div class="uptime-inline">
                        <strong>Local:</strong> <span id="current-time-text">—</span>
                    </div>
                    <div class="uptime-inline">
                        <strong>Uptime:</strong> <span id="uptime-text">—</span>
                        <strong>Free:</strong> <span id="space-text">—</span>
                        <strong>RTC:</strong> <span id="rtc-text">—</span>
                    </div>
                    <div class="uptime-inline">
                        <strong>Last line:</strong> <span id="last-line-text">—</span>
                    </div>
                </div>
            </div>

            <nav class="link-bar" aria-label="API endpoints">
                <a href="/get_data" data-endpoint="/get_data">
                    <span>Get data</span>
                    <span class="path">/get_data</span>
                </a>
                <a href="/clear_data" data-endpoint="/clear_data">
                    <span>Clear data</span>
                    <span class="path">/clear_data</span>
                </a>
                <a href="#" id="set-rtc-link">
                    <span>Set RTC</span>
                    <span class="path">/set_rtc</span>
                </a>
                <a href="/restart" data-endpoint="/restart">
                    <span>Restart</span>
                    <span class="path">/restart</span>
                </a>
            </nav>

            <section class="settings-card">
                <div class="settings-title">Settings</div>
                <form id="settings-form">
                    <div class="settings-row">
                        <div class="settings-field">
                            <label for="wifi-ssid" class="settings-label">WiFi SSID</label>
                            <input id="wifi-ssid" class="settings-input" type="text" name="wifi_ssid"
                                autocomplete="off" />
                        </div>
                        <div class="settings-field">
                            <label for="wifi-pass" class="settings-label">WiFi Password</label>
                            <input id="wifi-pass" class="settings-input" type="text" name="wifi_pass"
                                autocomplete="off" />
                        </div>
                        <button type="submit" class="settings-btn">
                            Send to /set_settings
                        </button>
                    </div>
                </form>
            </section>
        </header>

        <main class="main">
            <div class="output-header">
                <div class="output-label">
                    <span>Response</span>
                    <span class="output-label-code" id="current-endpoint-label">
                        (no request yet)
                    </span>
                    <span class="status" id="status-text">Idle</span>
                </div>
                <button type="button" class="copy-btn" id="copy-btn">
                    <span>Copy</span>
                </button>
            </div>
            <pre id="output" class="output" aria-label="Response output" tabindex="0"></pre>
        </main>
    </div>

    <script>
        (function () {
            const outputEl = document.getElementById("output");
            const statusEl = document.getElementById("status-text");
            const currentEndpointLabel = document.getElementById("current-endpoint-label");
            const copyBtn = document.getElementById("copy-btn");
            const links = Array.from(document.querySelectorAll("[data-endpoint]"));

            const uptimeTextEl = document.getElementById("uptime-text");
            const spaceTextEl = document.getElementById("space-text");
            const currentTimeTextEl = document.getElementById("current-time-text");
            const lastLineTextEl = document.getElementById("last-line-text");
            const rtcTextEl = document.getElementById("rtc-text");
            const setRtcLink = document.getElementById("set-rtc-link");

            const settingsForm = document.getElementById("settings-form");
            const wifiSsidInput = document.getElementById("wifi-ssid");
            const wifiPassInput = document.getElementById("wifi-pass");

            function setStatus(text) {
                statusEl.textContent = "· " + text;
            }

            function setActiveLink(activeLink) {
                links.forEach((lnk) => {
                    if (lnk === activeLink) {
                        lnk.classList.add("active");
                    } else {
                        lnk.classList.remove("active");
                    }
                });
            }

            async function callEndpoint(path, linkEl) {
                setActiveLink(linkEl);
                currentEndpointLabel.textContent = path + " (GET)";
                setStatus("…");
                outputEl.textContent = "";
                try {
                    const response = await fetch(path, {
                        method: "GET",
                        headers: {
                            Accept:
                                "application/json, text/plain;q=0.9, */*;q=0.8",
                        },
                    });

                    const contentType =
                        (response.headers.get("content-type") || "").toLowerCase();
                    let bodyText;

                    if (contentType.includes("application/json")) {
                        const data = await response.json();
                        bodyText = JSON.stringify(data, null, 2);
                    } else {
                        bodyText = await response.text();
                    }

                    if (!response.ok) {
                        outputEl.textContent =
                            "Error " +
                            response.status +
                            " " +
                            response.statusText +
                            "\n\n" +
                            bodyText;
                        setStatus("Error");
                    } else {
                        outputEl.textContent = bodyText || "(empty response)";
                        outputEl.scrollTop = outputEl.scrollHeight;
                        setStatus("OK (" + response.status + ")");
                    }
                } catch (err) {
                    outputEl.textContent =
                        "Request failed:\n" +
                        (err && err.message ? err.message : String(err));
                    setStatus("Network / fetch error");
                }
            }

            async function sendSettings(event) {
                event.preventDefault();

                const payload = {
                    wifi_pass: wifiPassInput.value,
                    wifi_ssid: wifiSsidInput.value,
                };

                setActiveLink(null);

                currentEndpointLabel.textContent = "/set_settings (POST)";
                setStatus("Sending settings…");
                outputEl.textContent =
                    "Request body:\n" + JSON.stringify(payload, null, 2) + "\n\nResponse:\n";

                try {
                    const response = await fetch("/set_settings", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            Accept:
                                "application/json, text/plain;q=0.9, */*;q=0.8",
                        },
                        body: JSON.stringify(payload),
                    });

                    const contentType =
                        (response.headers.get("content-type") || "").toLowerCase();
                    let bodyText;

                    if (contentType.includes("application/json")) {
                        const data = await response.json();
                        bodyText = JSON.stringify(data, null, 2);
                    } else {
                        bodyText = await response.text();
                    }

                    const sep = "\n----------------------------------------\n";
                    if (!response.ok) {
                        outputEl.textContent =
                            "Request body:\n" +
                            JSON.stringify(payload, null, 2) +
                            sep +
                            "Error " +
                            response.status +
                            " " +
                            response.statusText +
                            "\n\n" +
                            bodyText;
                        setStatus("Error");
                    } else {
                        outputEl.textContent =
                            "Request body:\n" +
                            JSON.stringify(payload, null, 2) +
                            sep +
                            (bodyText || "(empty response)");
                        setStatus("OK (" + response.status + ")");
                    }
                } catch (err) {
                    outputEl.textContent =
                        "Request body:\n" +
                        JSON.stringify(payload, null, 2) +
                        "\n\nRequest failed:\n" +
                        (err && err.message ? err.message : String(err));
                    setStatus("Network / fetch error");
                }
            }

            async function copyOutputToClipboard() {
                const text = outputEl.textContent.trim();
                if (!text) {
                    return;
                }

                const markCopied = () => {
                    copyBtn.dataset.copied = "true";
                    setTimeout(() => {
                        delete copyBtn.dataset.copied;
                    }, 1200);
                };

                try {
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        await navigator.clipboard.writeText(text);
                        markCopied();
                        return;
                    }
                } catch (e) { }

                try {
                    const ta = document.createElement("textarea");
                    ta.value = text;
                    ta.style.position = "fixed";
                    ta.style.left = "-9999px";
                    ta.style.top = "0";
                    document.body.appendChild(ta);
                    ta.focus();
                    ta.select();
                    const successful = document.execCommand("copy");
                    document.body.removeChild(ta);
                    if (successful) {
                        markCopied();
                    } else {
                        setStatus("Copy not supported");
                    }
                } catch (e) {
                    setStatus("Copy failed");
                }
            }

            // NEW: send local time to /set_rtc as JSON
            async function sendRtcFromLocalTime() {
                const now = new Date();
                const payload = {
                    year: now.getFullYear(),
                    month: now.getMonth() + 1,
                    day: now.getDate(),
                    hour: now.getHours(),
                    minute: now.getMinutes(),
                    second: now.getSeconds(),
                };

                setActiveLink(null);
                currentEndpointLabel.textContent = "/set_rtc (POST)";
                setStatus("Sending RTC…");
                outputEl.textContent =
                    "Request body:\n" + JSON.stringify(payload, null, 2) + "\n\nResponse:\n";

                try {
                    const response = await fetch("/set_rtc", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            Accept:
                                "application/json, text/plain;q=0.9, */*;q=0.8",
                        },
                        body: JSON.stringify(payload),
                    });

                    const contentType =
                        (response.headers.get("content-type") || "").toLowerCase();

                    let bodyText;
                    if (contentType.includes("application/json")) {
                        const data = await response.json();
                        bodyText = JSON.stringify(data, null, 2);
                    } else {
                        bodyText = await response.text();
                    }

                    const sep = "\n----------------------------------------\n";
                    if (!response.ok) {
                        outputEl.textContent =
                            "Request body:\n" +
                            JSON.stringify(payload, null, 2) +
                            sep +
                            "Error " +
                            response.status +
                            " " +
                            response.statusText +
                            "\n\n" +
                            bodyText;
                        setStatus("Error");
                    } else {
                        outputEl.textContent =
                            "Request body:\n" +
                            JSON.stringify(payload, null, 2) +
                            sep +
                            (bodyText || "(empty response)");
                        setStatus("OK (" + response.status + ")");
                    }
                } catch (err) {
                    outputEl.textContent =
                        "Request body:\n" +
                        JSON.stringify(payload, null, 2) +
                        "\n\nRequest failed:\n" +
                        (err && err.message ? err.message : String(err));
                    setStatus("Network / fetch error");
                }
            }

            function startUptimePolling() {
                const poll = async () => {
                    try {
                        const response = await fetch("/get_status", {
                            method: "GET",
                            cache: "no-store",
                            headers: { Accept: "application/json", },
                        });
                        const data = await response.json();
                        if (response.ok) {
                            uptimeTextEl.textContent = (data.uptime_usec / 1e6).toFixed(0) + "s";
                            const si = data.storage_space_info;
                            const space_total = si.total - si.min_allowed_free;
                            const space_free = si.free - si.min_allowed_free;
                            spaceTextEl.textContent = (space_free / space_total * 100).toFixed(1) + "%";
                            rtcTextEl.textContent = data.rtc_ts;
                            lastLineTextEl.textContent = data.last_line;
                        } else {
                            uptimeTextEl.textContent = "—";
                            spaceTextEl.textContent = "—";
                            rtcTextEl.textContent = "—";
                            lastLineTextEl.textContent = "—";
                        }
                    } catch (_err) {
                        uptimeTextEl.textContent = "err";
                        spaceTextEl.textContent = "err";
                        rtcTextEl.textContent = "err";
                        lastLineTextEl.textContent = "err";
                    }

                    try {
                        const now = new Date();
                        const year = now.getFullYear();
                        const month = String(now.getMonth() + 1).padStart(2, "0");
                        const day = String(now.getDate()).padStart(2, "0");
                        const hour = String(now.getHours()).padStart(2, "0");
                        const minute = String(now.getMinutes()).padStart(2, "0");
                        const second = String(now.getSeconds()).padStart(2, "0");
                        currentTimeTextEl.textContent = year + "-" + month + "-" + day + " " + hour + ":" + minute + ":" + second;
                    } catch (_err) {
                        currentTimeTextEl.textContent = "—";
                    }
                };

                poll();
                setInterval(poll, 1000);
            }

            async function loadSettings() {
                try {
                    const response = await fetch("/get_settings", {
                        method: "GET",
                        headers: {
                            Accept:
                                "application/json, text/plain;q=0.9, */*;q=0.8",
                        },
                    });

                    if (!response.ok) {
                        return;
                    }

                    const contentType =
                        (response.headers.get("content-type") || "").toLowerCase();

                    let data = null;

                    if (contentType.includes("application/json")) {
                        data = await response.json();
                    } else {
                        const text = await response.text();
                        try {
                            data = JSON.parse(text);
                        } catch (_e) {
                            data = null;
                        }
                    }

                    if (data && typeof data === "object") {
                        if ("wifi_ssid" in data && data.wifi_ssid != null) {
                            wifiSsidInput.value = String(data.wifi_ssid);
                        }
                        if ("wifi_pass" in data && data.wifi_pass != null) {
                            wifiPassInput.value = String(data.wifi_pass);
                        }
                    }
                } catch (_err) {
                    // ignore errors; keep inputs empty
                }
            }

            links.forEach((link) => {
                link.addEventListener("click", function (evt) {
                    evt.preventDefault();
                    const path = link.getAttribute("href");
                    callEndpoint(path, link);
                });
            });

            copyBtn.addEventListener("click", function () {
                copyOutputToClipboard();
            });

            if (setRtcLink) {
                setRtcLink.addEventListener("click", function (evt) {
                    evt.preventDefault();
                    sendRtcFromLocalTime();
                });
            }

            settingsForm.addEventListener("submit", sendSettings);

            setStatus("Idle");
            startUptimePolling();
            loadSettings();
        })();
    </script>
</body>

</html>